<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script src="https://d3js.org/topojson.v2.min.js"></script>
    <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Nunito" />
    <style>
        .country {
            fill: #fff;
            stroke: none;
        }
        .outline {
            stroke: darkgray;
            stroke-width: 1px;
            fill: none;
        }
        .centroid {
            fill-opacity: 0.8;
        }
        .legend span {
            margin-right: 5px;
        }
        .gridlines line {
            stroke: #bbb;
        }
        .gridlines .domain {
            stroke: none;
        }
        .title { 
            font-family: Nunito;
            font-size: 24px; 
            font-style: normal; 
            font-variant: normal; 
            font-weight: 700; 
            line-height: 26.4px; 
            text-anchor: middle;
        }
        .legend {
            font-family: Nunito;
            font-size: 12px;
        }
        .axis {
            font-family: Nunito;
            font-size: 9px;
        }

    </style>
    <title>Project 1</title>
</head>

<body>
    <svg id="choropleth" height="600" width="900" style="background: white; margin-top:20px" >
    </svg>

    <svg id="chart" height="600" width="900" style="background: #fff; margin-top:20px">
    </svg>
    <svg id="choropleth2" height="600" width="900" style="background: white; margin-top:20px" >
    </svg>
    <script id="map">
        const svg= d3.select("#choropleth");
        const width= svg.attr("width");
        const height= svg.attr("height");
        const margin = { top: 0, right: 0, bottom: 0, left:20};
        const mapWidth = width - margin.left - margin.right;
        const mapHeight = height - margin.top - margin.bottom;
        svg.append("text")
            .text("Gender Pay Gap versus Gender Education Gap")
            .attr("x", width/2 )
            .attr("y", 20 )
            .attr("class", "title");
        const map = svg.append("g")
                        .attr("transform","translate("+margin.left+","+margin.top+")");
        const requestData= async () => {
            // https://github.com/topojson/world-atlas#world/110m.json 
            const world = await d3.json("world.json");
            var countries= topojson.feature(world, world.objects.countries);
            var features= countries.features;
            var projection= d3.geoEqualEarth().fitSize([mapWidth, mapHeight], countries);
            var path= d3.geoPath().projection(projection);
            map.selectAll("path").data(countries.features)
                .enter()
                .append("path")
                .attr("class", "country")
                .attr("d", path)
                .attr("note", d=> d.id);
            map.append("path")
                .datum(topojson.mesh(world, world.objects.countries))
                .attr("class", "outline")
                .attr("d", path);
            const genderData= await d3.csv("gendergap.csv");
            const countryID= await d3.tsv("countries.tsv");
            let countryWageGap= {};
            let countryEducationGap= {};
            let idToCountry= {};
            countryID.forEach( row => {
                countryWageGap[row.name]= 0;
                countryEducationGap[row.name]=0;
                idToCountry[row.iso_n3]= row.name;
            });
            genderData.forEach( row=> {
                if (row.year=="2016" && row.type=="economic"){
                    countryWageGap[row.country]= Number(row.score);
                }
                if (row.year=="2016" && row.type=="education"){
                    countryEducationGap[row.country]= Number(row.score);
                }
            });
            const minMax= d3.extent(countryID, d=> countryWageGap[d.name]).reverse();
            const colorScale= d3.scaleSequential(d3.interpolateReds).domain(minMax);
            const minMaxEducation= d3.extent(countryID, d=> countryEducationGap[d.name]).reverse();
            const radScale= d3.scaleLinear().domain(minMaxEducation).range([5,50]);
            map.selectAll(".centroid").data(features)
                .enter().append("circle")
                    .attr("class", "centroid")
                    .attr("fill", d => colorScale( countryWageGap[ idToCountry[d.id] ] ))
                    .style("fill-opacity", function(d){ 
                        if (countryWageGap[ idToCountry[d.id] ]==0.0){ return 0.0}
                    })
                    .attr("r", d=> radScale(countryEducationGap[idToCountry[d.id]]))
                    .attr("cx", function (d){ return path.centroid(d)[0]; })
                    .attr("cy", function (d){ return path.centroid(d)[1]; });
                    
            const legend= svg.append("g")
                    .attr("class", "legend")
                    .attr("transform","translate(65,380)")
            legend.append("text")
                    .text("Pay Gap Scale")
                    .attr("transform","translate(70,0)")
            legend.append("text")
                    .attr("font-size", "10px")
                    .text("(% Difference between Men and Women)")
                    .attr("transform","translate(15,15)")
            const legendWidth= 220;
            const legendHeight = 50;;
            const barHeight = 20;
            const stepSize = 10;
            const pixelScale = d3.scaleLinear().domain([0,legendWidth-40]).range([minMax[0],minMax[1]]);
            const barScale = d3.scaleLinear().domain([minMax[0]-0.1,minMax[1]+0.1].reverse()).range([0,legendWidth-40]);
            const barAxis = d3.axisBottom(barScale).tickFormat(d3.format(".0%")).ticks(5);
            legend.append("g")
                .attr("class", "axis")
                .attr("transform","translate(20,40)")
                .call(barAxis);
            let bar = legend.append("g").attr("transform","translate(20,20)");
            for (let i=0; i<legendWidth-40; i=i+stepSize) {
                bar.append("rect")
                    .attr("x", i)
                    .attr("y", 0)
                    .attr("width", stepSize)
                    .attr("height",barHeight)
                    .style("fill", colorScale( pixelScale(i) )); 
            }
            
            const legend2= svg.append("g")
                    .attr("class", "legend")
                    .attr("transform","translate(50,300)")
            legend2.append("text")
                .text("Education Gap Scale")
                .attr("transform","translate(70,0)")
            const sizeScale= d3.scaleLinear().domain([0,50]).range([minMaxEducation[0],minMaxEducation[1]]);

            // const chart= d3.select("#chart");
            // const svgWidth= svg.attr("width");
            // const svgHeight= svg.attr("height");
            // const chartMargin = { top: 100, right: 100, bottom: 100, left: 100};
            // let chartWidth= svgWidth - chartMargin.left - chartMargin.right;
            // let chartHeight= svgHeight - chartMargin.top - chartMargin.bottom;
            // const wageScale= d3.scaleLinear().domain(minMax.reverse()).range([0,chartWidth]);
            // const educationScale= d3.scaleLinear().domain(minMaxEducation.reverse()).range([chartHeight, 0]);
            // let leftAxis= d3.axisLeft(educationScale).ticks(20);
            // chart.append("g")
            //     .attr("transform", "translate("+ chartMargin.left +","+ chartMargin.top +")")
            //     .call(leftAxis);
            // let bottomAxis= d3.axisBottom(wageScale).ticks(20)
            // let element= chart.append("g")
            //     .attr("transform", "translate("+ chartMargin.left +","+ (chartMargin.top + chartHeight) +")");
            // bottomAxis(element);
            // let leftGridlines= d3.axisLeft(educationScale).tickSize(-chartWidth-10).tickFormat("");
            // chart.append("g").attr("class", "gridlines")
            //     .attr("transform","translate("+ chartMargin.left +","+ chartMargin.top +")")
            //     .call(leftGridlines);
            // let bottomGridlines = d3.axisBottom(wageScale).tickSize(-chartHeight).tickFormat("").ticks(20);
            // element = chart.append("g").attr("class", "gridlines")
            //     .attr("transform","translate("+ chartMargin.left +","+ (chartMargin.top + chartHeight) +")");
            // bottomGridlines(element);
            // let scatter = chart.append("g")
            //     .attr("transform","translate("+chartMargin.left+","+chartMargin.top+")");
            // let count=0
            // countryID.forEach( row => {
            //     let wage= wageScale(countryWageGap[idToCountry[row.iso_n3]]);
            //     let education= educationScale(countryEducationGap[idToCountry[row.iso_n3]]);
            //     if (wage!=0.0 && education!=0.0){
            //         let circle= scatter.append("circle")
            //             .attr("cx", wage)
            //             .attr("cy", education)
            //             .attr("r", 8)
            //             .style("fill-opacity", 0.7)
            //             .style("fill", "red");
            //         count+=1;
            //     };
            // });
            // chart.append("text")
            //     .attr("x", svgWidth/2 )
            //     .attr("y", svgHeight-50 )
            //     .style("text-anchor", "middle")
            //     .text("Wage");
        };
        requestData();

    </script>

</body>
</html>